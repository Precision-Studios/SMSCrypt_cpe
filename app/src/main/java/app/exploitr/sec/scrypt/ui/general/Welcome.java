package app.exploitr.sec.scrypt.ui.general;

import android.app.KeyguardManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.hardware.biometrics.BiometricManager;
import android.hardware.biometrics.BiometricPrompt;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.telephony.TelephonyManager;
import android.text.Editable;
import android.view.View;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.IntentSenderRequest;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;

import com.google.android.gms.auth.api.identity.GetPhoneNumberHintIntentRequest;
import com.google.android.gms.auth.api.identity.Identity;
import com.google.android.gms.tasks.OnFailureListener;

import java.security.GeneralSecurityException;

import app.exploitr.sec.scrypt.database.LocalDatabase;
import app.exploitr.sec.scrypt.databinding.ActivityWelcomeBinding;
import app.exploitr.sec.scrypt.databinding.MasterPwdReinBinding;
import app.exploitr.sec.scrypt.utils.Core;
import app.exploitr.sec.scrypt.utils.Iso2Phone;

public class Welcome extends AppCompatActivity {

    private KeyguardManager keyguardManager;
    private ActivityWelcomeBinding binding;

    ActivityResultLauncher<IntentSenderRequest> phoneNumberHintIntentResultLauncher =
            registerForActivityResult(
                    new ActivityResultContracts.StartIntentSenderForResult(), result -> {
                        try {
                            if (result.getData() != null) {
                                String phoneNumber = Identity.getSignInClient(getApplicationContext()).getPhoneNumberFromIntent(result.getData());
                                if (binding != null)
                                    binding.phoneInput.setText(phoneNumber);
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            Toast.makeText(this, "Could not extract phone number from hint.", Toast.LENGTH_SHORT).show();
                        }
                    });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityWelcomeBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        keyguardManager = (KeyguardManager) getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);

        if (secureDevice()) {
            set_up();
        } else {
            Toast.makeText(this, "Please enable screen lock to use the application.", Toast.LENGTH_LONG).show();
            finishAndRemoveTask();
        }
    }

    private void set_up() {
        var biometric = new BiometricPrompt.Builder(this)
                .setConfirmationRequired(true)
                .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG | BiometricManager.Authenticators.DEVICE_CREDENTIAL)
                .setTitle("Confirm Device Lock")
                .setSubtitle("Please prove device ownership.")
                .build();

        var authCallback = new BiometricPrompt.AuthenticationCallback() {
            @Override
            public void onAuthenticationError(int errorCode, CharSequence errString) {
                if (isACaseOf(errorCode, BiometricPrompt.BIOMETRIC_ERROR_HW_UNAVAILABLE, BiometricPrompt.BIOMETRIC_ERROR_HW_NOT_PRESENT,
                        BiometricPrompt.BIOMETRIC_ERROR_CANCELED, BiometricPrompt.BIOMETRIC_ERROR_USER_CANCELED, BiometricPrompt.BIOMETRIC_ERROR_VENDOR
                        , BiometricPrompt.BIOMETRIC_ERROR_LOCKOUT_PERMANENT)) {
                    Toast.makeText(Welcome.this, "Can't work without biometrics!", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (errorCode == BiometricPrompt.BIOMETRIC_ERROR_NO_BIOMETRICS) {
                    Toast.makeText(Welcome.this, "Please setup biometric in settings!", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (errorCode == BiometricPrompt.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED) {
                    Toast.makeText(Welcome.this, "Missing Security Patch! Please update the OS.", Toast.LENGTH_LONG).show();
                    finishAndRemoveTask();
                } else if (isACaseOf(errorCode, BiometricPrompt.BIOMETRIC_ERROR_LOCKOUT
                        , BiometricPrompt.BIOMETRIC_ERROR_TIMEOUT, BiometricPrompt.BIOMETRIC_ERROR_UNABLE_TO_PROCESS)) {
                    Toast.makeText(Welcome.this, "Biometric temporarily blocked, retry after sometime , Code: " + errorCode, Toast.LENGTH_SHORT).show();
                    finishAndRemoveTask();
                } else {
                    Toast.makeText(Welcome.this, "Error : Biometric is disabled | Code : " + errorCode, Toast.LENGTH_SHORT).show();
                    finishAndRemoveTask();
                }
                super.onAuthenticationError(errorCode, errString);
            }

            @Override
            public void onAuthenticationHelp(int helpCode, CharSequence helpString) {
                Toast.makeText(Welcome.this, helpString, Toast.LENGTH_SHORT).show();
                super.onAuthenticationHelp(helpCode, helpString);
            }

            @Override
            public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                moveForward();
                super.onAuthenticationSucceeded(result);
            }

            @Override
            public void onAuthenticationFailed() {
                Toast.makeText(Welcome.this, "Couldn't verify screen lock, try again?", Toast.LENGTH_SHORT).show();
                binding.retryAuth.setVisibility(View.VISIBLE);
                binding.loadingWelcome.setVisibility(View.INVISIBLE);
                binding.aliasLayout.setVisibility(View.INVISIBLE);
                binding.phoneLayout.setVisibility(View.INVISIBLE);
                binding.signUpAnim.setVisibility(View.INVISIBLE);
                binding.masterPassLayout.setVisibility(View.INVISIBLE);
                binding.continueNext.setVisibility(View.INVISIBLE);
                binding.pwdWarn.setVisibility(View.INVISIBLE);
                super.onAuthenticationFailed();
            }
        };

        var cal = new CancellationSignal();
        cal.setOnCancelListener(() -> {
            Toast.makeText(Welcome.this, "Authentication cancelled!", Toast.LENGTH_SHORT).show();
            binding.retryAuth.setVisibility(View.VISIBLE);
            binding.retryAuth.setOnClickListener(v -> biometric.authenticate(cal, ContextCompat.getMainExecutor(Welcome.this), authCallback));
        });

        if (Core.ENABLE_TEST_MODE) {
            startActivity(new Intent(Welcome.this, MainActivity.class));
            Welcome.this.finish();
        } else {
            biometric.authenticate(cal, ContextCompat.getMainExecutor(this), authCallback);
        }

        binding.retryAuth.setOnClickListener(v -> {
            binding.loadingWelcome.setVisibility(View.VISIBLE);
            binding.retryAuth.setVisibility(View.INVISIBLE); // Hide retry button while authenticating
            biometric.authenticate(cal, ContextCompat.getMainExecutor(this), authCallback);
        });

        binding.phoneInput.setOnFocusChangeListener((view, b) -> {
            if (b) {
                showPhoneNumberOptions();
            }
        });
    }

    private boolean isACaseOf(int code, int... list_of_codes) {
        for (int any : list_of_codes) {
            if (any == code) {
                return true;
            }
        }
        return false;
    }

    private void showPhoneNumberOptions() {
        GetPhoneNumberHintIntentRequest request = GetPhoneNumberHintIntentRequest.builder().build();

        Identity.getSignInClient(this)
                .getPhoneNumberHintIntent(request)
                .addOnSuccessListener(pendingIntent -> {
                    try {
                        phoneNumberHintIntentResultLauncher.launch(new IntentSenderRequest.Builder(pendingIntent.getIntentSender()).build());
                    } catch (Exception e) {
                        e.printStackTrace();
                        Toast.makeText(this, "Could not launch phone number hint picker.", Toast.LENGTH_SHORT).show();
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        e.printStackTrace();
                        Toast.makeText(Welcome.this, "Failed to get phone number hint: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                    }
                });
    }


    private void moveForward() {
        LocalDatabase da = LocalDatabase.getInstance(getBaseContext());

        if (da.getPhone() != null && !da.getPhone().isEmpty()) {
            startActivity(new Intent(Welcome.this, MainActivity.class));
            Welcome.this.finish();
            return;
        }

        // Authentication succeeded, show the setup UI
        binding.retryAuth.setVisibility(View.INVISIBLE);
        binding.loadingWelcome.setVisibility(View.INVISIBLE);
        binding.aliasLayout.setVisibility(View.VISIBLE);
        binding.phoneLayout.setVisibility(View.VISIBLE);
        binding.signUpAnim.setVisibility(View.VISIBLE);
        binding.masterPassLayout.setVisibility(View.VISIBLE);
        binding.continueNext.setVisibility(View.VISIBLE);
        binding.pwdWarn.setVisibility(View.VISIBLE);

        TelephonyManager telephonyManager = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
        if (telephonyManager != null && telephonyManager.getNetworkCountryIso() != null) {
            binding.phoneInput.setText(Iso2Phone.getPhone(telephonyManager.getNetworkCountryIso()));
        }

        binding.aliasInput.setText(""); // Clear alias input initially

        binding.continueNext.setOnClickListener(v -> {
            Editable aliasText;
            Editable phoneText;
            Editable masterPassText;

            boolean clear = true;

            // Clear previous errors
            binding.aliasLayout.setError(null);
            binding.phoneLayout.setError(null);
            binding.masterPassLayout.setError(null);

            aliasText = binding.aliasInput.getText();
            if (aliasText == null || aliasText.length() < 3) {
                binding.aliasLayout.setError("Too short alias name!");
                clear = false;
            }

            phoneText = binding.phoneInput.getText();
            if (phoneText == null || phoneText.length() < 6) { // Basic validation, consider more robust check
                binding.phoneLayout.setError("Invalid phone number!");
                clear = false;
            }

            masterPassText = binding.masterPassInput.getText();
            if (masterPassText == null || masterPassText.length() < 4) {
                binding.masterPassLayout.setError("Too short encryption key!");
                clear = false;
            }

            if (clear) {
                // All inputs seem valid, proceed
                da.setAlias(aliasText.toString());
                da.setPhone(phoneText.toString());
                try {
                    da.setMasterPasswordEncryptedText(masterPassText.toString());
                    testIfUserCanRecallMasterPwd(da);
                } catch (GeneralSecurityException e) {
                    binding.masterPassLayout.setError("Encryption error!");
                    Toast.makeText(this, "Error setting master password.", Toast.LENGTH_SHORT).show();
                    e.printStackTrace();
                }
            }
        });
    }

    private void testIfUserCanRecallMasterPwd(LocalDatabase da) {
        AlertDialog alertDialog = createDialogue(da);
        if (!this.isFinishing() && !this.isDestroyed()) {
            alertDialog.show();
        }
    }

    private AlertDialog createDialogue(LocalDatabase da) {
        MasterPwdReinBinding dialogBinding = MasterPwdReinBinding.inflate(getLayoutInflater());

        dialogBinding.masterPwdReinReason.setText("Re-enter Master Password to verify");

        AlertDialog dialog = new AlertDialog.Builder(Welcome.this)
                .setView(dialogBinding.getRoot())
                .setCancelable(false) // Prevent dismissing by tapping outside
                .setNegativeButton("Cancel", null) // Changed from Retry to Cancel
                .setPositiveButton("Verify", null)
                .setTitle("Confirm Master Password")
                .create();

        dialog.setOnShowListener(dialog_ -> {
            dialog.getButton(AlertDialog.BUTTON_POSITIVE)
                    .setOnClickListener(v -> {
                        dialogBinding.masterPwdReinLayout.setError(null); // Clear previous error
                        Editable pass = dialogBinding.masterPwdReinInput.getText();
                        if (pass != null) {
                            try {
                                if (da.getMasterPasswordVerificationTestSuccess(pass.toString())) {
                                    dialogBinding.masterPwdReinInput.setText(""); // Clear password field
                                    dialog_.dismiss();
                                    // Password verified, proceed to main activity
                                    startActivity(new Intent(Welcome.this, MainActivity.class));
                                    Welcome.this.finish();
                                } else {
                                    dialogBinding.masterPwdReinLayout.setError("Wrong encryption key!");
                                }
                            } catch (GeneralSecurityException e) {
                                dialogBinding.masterPwdReinLayout.setError("Verification failed!");
                                Toast.makeText(this, "Error verifying password.", Toast.LENGTH_SHORT).show();
                                e.printStackTrace();
                            }
                        } else {
                             dialogBinding.masterPwdReinLayout.setError("Password cannot be empty!");
                        }
                    });

            dialog.getButton(DialogInterface.BUTTON_NEGATIVE).setOnClickListener(v -> {
                dialog.dismiss();
                // User cancelled verification, clear the potentially set password
                try {
                    da.setMasterPasswordEncryptedText(""); // Clear the password as verification was cancelled
                } catch (GeneralSecurityException e) {
                    Toast.makeText(this, "Error clearing password.", Toast.LENGTH_SHORT).show();
                    e.printStackTrace();
                }
                // Optionally, clear other fields as well or guide the user
                 binding.masterPassInput.setText(""); // Clear the original password input
                 Toast.makeText(this, "Password setup cancelled.", Toast.LENGTH_SHORT).show();
            });
        });

        return dialog;
    }


    private boolean secureDevice() {
        // isKeyguardSecure is deprecated but needed for older APIs
        // isDeviceSecure is the preferred check for API 23+
        return keyguardManager != null && keyguardManager.isDeviceSecure();
    }
}
